use std::str::FromStr;
use std::f32::consts::PI;
use ast::{Expr, Argument, Program, MathExp, UnaryOp, BinaryOp};

grammar;

pub Program: Program = {
  <v:Version> <e:Expr*> => Program {
    version: v,
    body: e
  }
};

Expr: Expr = {
  QReg, CReg, Reset, Measure, Barrier, Application, Opaque, Conditional, Gate,
};

// Version
Version: f32 = "OPENQASM" <Real> ";";

// Register Initializations;
QReg: Expr = "qreg" <a:Id> "[" <i:Int> "]" ";" => Expr::QReg(a, i);
CReg: Expr = "creg" <a:Id> "[" <i:Int> "]" ";" => Expr::CReg(a, i);

// Quantum Operations
Reset: Expr = "reset" <Arg> ";" => Expr::Reset(<>);
Measure: Expr = "measure" <Arg> "->" <Arg> ";" => Expr::Measure(<>);

// Barrier
Barrier: Expr = "barrier" <Comma<Arg>> ";" => Expr::Barrier(<>);

// Gate Application
Application: Expr = {
    <id:Id> <args:Comma<Arg>> ";" => Expr::Application(id, args, vec![]),
    "CX" <control: Arg> "," <target: Arg> ";" => Expr::Application(String::from("CX"), vec![control, target], vec![]),
    "U" "(" <params:Comma<MathExp>> ")" <args:Comma<Arg>> ";" => Expr::Application(String::from("U"), args, params),
    <id:Id> "(" <params:Comma<MathExp>> ")" <args:Comma<Arg>> ";" => Expr::Application(id, args, params),
};

// Gate Creation
Opaque: Expr = "opaque"  <id:Id> "(" <params:Comma<MathExp>> ")" <args:Comma<Arg>> ";" => Expr::Opaque(id, args, params);
Gate: Expr = {
    "gate" <id:Id> "(" <params:Comma<Id>> ")" <qargs:Comma<Id>> "{" <e:ExpressionList> "}" => Expr::Gate(id, params, qargs, e),
    "gate" <id:Id> <qargs:Comma<Id>> "{" <e:ExpressionList> "}" => Expr::Gate(id, vec![], qargs, e),
};

// Conditional
Conditional: Expr = "if" "(" <id:Id> "==" <n:Int> ")" <e:Expr> => Expr::Conditional(id, n, Box::new(e));

// Arguments
Arg: Argument = {
  <id:Id> "[" <i:Int> "]" => Argument::Qubit(id, i),
  Id => Argument::Register(<>)
};

// Expression List
BoxedExpr: Box<Expr> = <Expr> => Box::new(<>);
ExpressionList: Vec<Box<Expr>> = <e:BoxedExpr*> => e;

// Literals / Base Expressions
Id: String = r"[a-z][A-Za-z0-9_]*" => <>.into();
Int: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
Real: f32 = r"[0-9]*\.[0-9]+" => f32::from_str(<>).unwrap();

// Macros
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// A math expression in OpenQASM is either
// real, an integer, pi, an id. Then, An expression can be
// combined with <exp> + <exp>, <exp> + <exp>, <exp> * <exp>
// <exp> / <exp>, - <exp>, <exp> ^ <exp>, (<exp>), <unaryop> (<exp>)
MathExp: Box<MathExp> = {
    <UnaryOp> "(" <MathExp> ")" => Box::new(MathExp::Unary(<>)),

    Additive
};

Additive: Box<MathExp> = {
    MathExp ExpOp Factor => Box::new(MathExp::Binary(<>)),
    Factor,
};

Factor: Box<MathExp> = {
    Factor FactorOp Term => Box::new(MathExp::Binary(<>)),
    Term
};

Term: Box<MathExp> = {
    Real => Box::new(MathExp::Number(<>)),
    Int => Box::new(MathExp::Number(<> as f32)),
    "pi" => Box::new(MathExp::Number(PI)),
    Id => Box::new(MathExp::Variable(<>)) ,
    "(" <MathExp> ")",
};

ExpOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

FactorOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "^" => BinaryOp::Pow,
};

UnaryOp: UnaryOp = {
    "sin" => UnaryOp::Sin,
    "sin" => UnaryOp::Sin,
    "cos" => UnaryOp::Cos,
    "tan" => UnaryOp::Tan,
    "exp" => UnaryOp::Exp,
    "ln" => UnaryOp::Ln,
    "sqrt" => UnaryOp::Sqrt,
};
